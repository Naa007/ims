package com.stepup.ims.service;

import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.layout.Document;
import com.itextpdf.layout.element.Cell;
import com.itextpdf.layout.element.Paragraph;
import com.itextpdf.layout.element.Table;
import com.itextpdf.layout.properties.UnitValue;
import com.stepup.ims.model.Inspection;
import com.stepup.ims.modelmapper.InspectionModelMapper;
import com.stepup.ims.repository.InspectionRepository;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

@Service
public class ReportsService {

    @Autowired
    private InspectionService inspectionService;

    @Autowired
    private EmployeeService employeeService;

    @Autowired
    private InspectionRepository inspectionRepository;

    @Autowired
    private InspectionModelMapper inspectionModelMapper;

    public byte[] generateReport(String period, String from, String to, String format) throws IllegalAccessException {

        List<Inspection> inspections = inspectionService.getInspectionsBetweenDates(from, to);
        String reportName = "Inspections_" + period + "_" + from.split("T")[0] + "_" + to.split("T")[0] + "." + format.toLowerCase();
        return switch (format.toLowerCase()) {
            case "pdf" -> generatePdfReport(reportName, inspections);
            case "excel" -> generateExcelReport(reportName, inspections);
            default -> throw new IllegalArgumentException("Unsupported format: " + format);
        };
    }

    private byte[] generatePdfReport(String reportName, List<Inspection> inspections) throws IllegalAccessException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        PdfWriter writer = new PdfWriter(out);
        PdfDocument pdf = new PdfDocument(writer);
        Document document = new Document(pdf);


        document.add(new Paragraph("Inspections Report: " + reportName));
        document.add(new Paragraph("Generated by: " + employeeService.getEmployeeNameByEmail(SecurityContextHolder.getContext().getAuthentication().getName())));
        document.add(new Paragraph("Generated on: " + LocalDateTime.now()));
        document.add(new Paragraph("\n"));

        // Create a table with dynamic column count based on the number of Inspection fields
        if (!inspections.isEmpty()) {
            Inspection sampleInspection = inspections.get(0);
            var fields = sampleInspection.getClass().getDeclaredFields();

            Table table = new Table(UnitValue.createPercentArray(fields.length));
            table.setWidth(UnitValue.createPercentValue(100));

            // Add headers (field names) to the table
            for (var field : fields) {
                field.setAccessible(true);
                table.addHeaderCell(new Cell().add(new Paragraph(field.getName())));
            }

            // Add inspection data rows
            for (Inspection inspection : inspections) {
                for (var field : fields) {
                    field.setAccessible(true);
                    Object value = field.get(inspection);
                    table.addCell(new Cell().add(new Paragraph(value != null ? value.toString() : "")));
                }
            }

            document.add(table);
        }
        document.close();
        return out.toByteArray();
    }

    private byte[] generateExcelReport(String sheetName, List<Inspection> inspections) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        if (inspections.isEmpty()) {
            return new byte[0];
        }
        try (Workbook workbook = new XSSFWorkbook()) {
            Sheet sheet = workbook.createSheet(sheetName);

            // Setting up header row
            Row headerRow = sheet.createRow(0);
            if (!inspections.isEmpty()) {
                Inspection sampleInspection = inspections.get(0);
                var fields = sampleInspection.getClass().getDeclaredFields();
                for (int i = 0; i < fields.length; i++) {
                    fields[i].setAccessible(true);
                    headerRow.createCell(i).setCellValue(fields[i].getName());
                }

                // Writing data rows
                for (int rowIndex = 0; rowIndex < inspections.size(); rowIndex++) {
                    Row dataRow = sheet.createRow(rowIndex + 1);
                    Inspection inspection = inspections.get(rowIndex);
                    for (int colIndex = 0; colIndex < fields.length; colIndex++) {
                        fields[colIndex].setAccessible(true);
                        Object value = fields[colIndex].get(inspection);
                        dataRow.createCell(colIndex).setCellValue(value != null ? value.toString() : "");
                    }
                }
            }

            workbook.write(out);
        } catch (IOException | IllegalAccessException e) {
            e.printStackTrace();
            throw new RuntimeException("Error creating Excel report", e);
        }
        return out.toByteArray();
    }
}
